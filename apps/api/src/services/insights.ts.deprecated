import { PrismaDatabaseService } from './database-prisma';

interface TechStackAnalysisResult {
  technology: string;
  frequency: number;
  category: string;
  importance: string;
  description: string;
}

interface SkillGap {
  skill: string;
  priority: string;
  frequency: number;
  reasoning: string;
  learningPath: string;
}

interface CareerRecommendation {
  type: string;
  title: string;
  priority: string;
  description: string;
  actionItems: string[];
  timeframe: string;
}

interface MarketTrend {
  trend: string;
  growth: string;
  description: string;
  impact: string;
}

interface TechTrendResult {
  technology: string;
  mentions: number;
  percentage: number;
  category: string;
  trend: string;
}

export class InsightsService {
  private db: PrismaDatabaseService;

  constructor() {
    this.db = new PrismaDatabaseService();
  }

  async initialize(): Promise<void> {
    await this.db.init();
  }

  /**
   * Generates comprehensive career insights based on actual job data
   */
  async generateCareerInsights(userId: string): Promise<any> {
    try {
      // Get user's tracked jobs to understand their interests
      const userJobs = await this.db.client.userJob.findMany({
        where: { userId },
        include: {
          job: {
            include: {
              insights: true
            }
          }
        }
      });

      // Get all jobs with insights for market analysis
      const allJobs = await this.db.client.job.findMany({
        where: {
          insights: {
            isNot: null
          }
        },
        include: {
          insights: true
        },
        orderBy: {
          createdAt: 'desc'
        },
        take: 500 // Analyze recent 500 jobs
      });

      const totalJobs = allJobs.length;
      
      if (totalJobs === 0) {
        // Return mock data if no real data available
        return this.getMockInsights(userJobs.length);
      }

      // Analyze technology trends
      const techStackAnalysis = await this.analyzeTechStack(allJobs);
      
      // Identify skill gaps based on user's tracked jobs vs market
      const skillGaps = await this.identifySkillGaps(userJobs, allJobs);
      
      // Generate personalized recommendations
      const recommendations = await this.generateRecommendations(userJobs, techStackAnalysis, skillGaps);
      
      // Analyze market trends
      const marketTrends = await this.analyzeMarketTrends(allJobs);
      
      return {
        techStackAnalysis,
        skillGaps,
        recommendations,
        marketTrends,
        preparationAdvice: this.generatePreparationAdvice(skillGaps, techStackAnalysis),
        metadata: {
          analyzedJobs: totalJobs,
          trackedJobs: userJobs.length,
          generatedAt: new Date().toISOString(),
          dataFreshness: 'current'
        }
      };

    } catch (error) {
      console.error('Error generating career insights:', error);
      // Return mock data on error
      return this.getMockInsights(0);
    }
  }

  /**
   * Gets technology trend analysis from real database data
   */
  async getTechTrends(userId: string): Promise<any> {
    try {
      // Get all jobs with insights for trend analysis
      const allJobs = await this.db.client.job.findMany({
        where: {
          insights: {
            isNot: null
          },
          createdAt: {
            gte: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000) // Last 30 days
          }
        },
        include: {
          insights: true
        }
      });

      const userJobs = await this.db.client.userJob.count({
        where: { userId }
      });

      if (allJobs.length === 0) {
        return this.getMockTechTrends(userJobs);
      }

      // Aggregate technology mentions
      const techCounts: Record<string, { count: number; category: string }> = {};
      const totalJobs = allJobs.length;

      allJobs.forEach(job => {
        if (job.insights?.technologies) {
          const technologies = job.insights.technologies as any[];
          technologies.forEach((tech: any) => {
            if (tech.confidence > 0.6) { // Only count high-confidence mentions
              if (!techCounts[tech.name]) {
                techCounts[tech.name] = { count: 0, category: tech.category || 'Other' };
              }
              techCounts[tech.name].count++;
            }
          });
        }
      });

      // Convert to trending technologies format
      const trendingTechnologies: TechTrendResult[] = Object.entries(techCounts)
        .map(([technology, data]) => ({
          technology,
          mentions: data.count,
          percentage: Math.round((data.count / totalJobs) * 100),
          category: data.category,
          trend: this.calculateTrend(data.count, totalJobs)
        }))
        .sort((a, b) => b.mentions - a.mentions)
        .slice(0, 20); // Top 20 technologies

      return {
        trendingTechnologies,
        totalJobsAnalyzed: totalJobs,
        userTrackedJobs: userJobs,
        lastUpdated: new Date().toISOString()
      };

    } catch (error) {
      console.error('Error analyzing tech trends:', error);
      return this.getMockTechTrends(0);
    }
  }

  /**
   * Analyzes tech stack popularity from job insights
   */
  private async analyzeTechStack(jobs: any[]): Promise<TechStackAnalysisResult[]> {
    const techCounts: Record<string, { count: number; category: string }> = {};
    const totalJobs = jobs.length;

    jobs.forEach(job => {
      if (job.insights?.technologies) {
        const technologies = job.insights.technologies as any[];
        technologies.forEach((tech: any) => {
          if (tech.confidence > 0.7) { // High confidence only
            if (!techCounts[tech.name]) {
              techCounts[tech.name] = { count: 0, category: tech.category || 'Other' };
            }
            techCounts[tech.name].count++;
          }
        });
      }
    });

    return Object.entries(techCounts)
      .map(([technology, data]) => {
        const frequency = Math.round((data.count / totalJobs) * 100);
        return {
          technology,
          frequency,
          category: data.category,
          importance: frequency > 70 ? 'Critical' : frequency > 50 ? 'High' : frequency > 30 ? 'Medium' : 'Low',
          description: this.getTechnologyDescription(technology, frequency)
        };
      })
      .sort((a, b) => b.frequency - a.frequency)
      .slice(0, 10); // Top 10 technologies
  }

  /**
   * Identifies skill gaps based on user's tracked jobs vs market demand
   */
  private async identifySkillGaps(userJobs: any[], allJobs: any[]): Promise<SkillGap[]> {
    if (allJobs.length === 0) {
      return this.getMockSkillGaps();
    }

    // Get technologies from user's tracked jobs with improved confidence scoring
    const userTechs = new Map<string, number>();
    const userTechCategories = new Set<string>();
    
    userJobs.forEach(userJob => {
      if (userJob.job?.insights?.technologies) {
        const technologies = userJob.job.insights.technologies as any[];
        technologies.forEach((tech: any) => {
          if (tech.confidence > 0.6) { // Slightly lower threshold for user skills
            const normalizedName = tech.name.toLowerCase().trim();
            userTechs.set(normalizedName, (userTechs.get(normalizedName) || 0) + 1);
            if (tech.category) {
              userTechCategories.add(tech.category.toLowerCase());
            }
          }
        });
      }
    });

    // Analyze market demand for all technologies
    const marketTechs: Record<string, { count: number; category: string; avgConfidence: number }> = {};
    const totalJobsWithTech = allJobs.filter(job => job.insights?.technologies?.length > 0).length;
    
    allJobs.forEach(job => {
      if (job.insights?.technologies) {
        const technologies = job.insights.technologies as any[];
        technologies.forEach((tech: any) => {
          if (tech.confidence > 0.7) {
            const normalizedName = tech.name.toLowerCase().trim();
            if (!marketTechs[normalizedName]) {
              marketTechs[normalizedName] = {
                count: 0,
                category: tech.category || 'Other',
                avgConfidence: 0
              };
            }
            marketTechs[normalizedName].count++;
            marketTechs[normalizedName].avgConfidence += tech.confidence;
          }
        });
      }
    });

    // Calculate averages and identify gaps
    const skillGaps: SkillGap[] = [];
    
    Object.entries(marketTechs).forEach(([skill, data]) => {
      const normalizedSkill = skill.toLowerCase().trim();
      const userHasSkill = userTechs.has(normalizedSkill);
      
      if (!userHasSkill) {
        const frequency = Math.round((data.count / totalJobsWithTech) * 100);
        const avgConfidence = data.avgConfidence / data.count;
        
        // Enhanced priority calculation
        let priority = 'Low';
        if (frequency > 60 && avgConfidence > 0.8) {
          priority = 'Critical';
        } else if (frequency > 40 || (frequency > 25 && avgConfidence > 0.85)) {
          priority = 'High';
        } else if (frequency > 20) {
          priority = 'Medium';
        }
        
        // Only include significant gaps
        if (frequency >= 15) {
          skillGaps.push({
            skill: this.capitalizeWords(skill),
            priority,
            frequency,
            reasoning: this.generateGapReasoning(skill, frequency, data.category, userTechCategories),
            learningPath: this.generateEnhancedLearningPath(skill, data.category, priority)
          });
        }
      }
    });

    // Sort by priority and frequency
    const priorityOrder = { 'Critical': 4, 'High': 3, 'Medium': 2, 'Low': 1 };
    return skillGaps
      .sort((a, b) => {
        const priorityDiff = (priorityOrder[a.priority] || 0) - (priorityOrder[b.priority] || 0);
        if (priorityDiff !== 0) return -priorityDiff;
        return b.frequency - a.frequency;
      })
      .slice(0, 6); // Top 6 skill gaps
  }

  /**
   * Generates personalized career recommendations
   */
  private async generateRecommendations(userJobs: any[], techStack: TechStackAnalysisResult[], skillGaps: SkillGap[]): Promise<CareerRecommendation[]> {
    const recommendations: CareerRecommendation[] = [];

    // High-priority skill gap recommendation
    if (skillGaps.length > 0 && skillGaps[0].priority === 'High') {
      recommendations.push({
        type: 'Upskill',
        title: `Master ${skillGaps[0].skill}`,
        priority: 'High',
        description: `${skillGaps[0].skill} appears in ${skillGaps[0].frequency}% of job postings and could significantly boost your marketability`,
        actionItems: [
          `Learn ${skillGaps[0].skill} fundamentals`,
          `Build a project showcasing ${skillGaps[0].skill}`,
          `Add ${skillGaps[0].skill} to your resume and portfolio`
        ],
        timeframe: '2-3 months'
      });
    }

    // Technology trend recommendation
    const trendingTech = techStack.find(tech => tech.frequency > 60 && tech.importance === 'Critical');
    if (trendingTech) {
      recommendations.push({
        type: 'Strengthen',
        title: `Deepen ${trendingTech.technology} Expertise`,
        priority: 'High',
        description: `${trendingTech.technology} is critical in ${trendingTech.frequency}% of job postings`,
        actionItems: [
          `Take advanced ${trendingTech.technology} courses`,
          `Contribute to ${trendingTech.technology} open source projects`,
          `Build complex applications using ${trendingTech.technology}`
        ],
        timeframe: '3-6 months'
      });
    }

    // Portfolio enhancement recommendation
    recommendations.push({
      type: 'Improve',
      title: 'Build a Comprehensive Portfolio',
      priority: 'Medium',
      description: 'Showcase your skills with projects that demonstrate real-world problem solving',
      actionItems: [
        'Create 3-5 polished projects covering different aspects of development',
        'Include projects that use the most in-demand technologies',
        'Document your projects with clear READMEs and live demos'
      ],
      timeframe: '1-2 months'
    });

    return recommendations.slice(0, 3); // Top 3 recommendations
  }

  /**
   * Analyzes market trends from job data
   */
  private async analyzeMarketTrends(jobs: any[]): Promise<MarketTrend[]> {
    // Analyze experience level distribution
    const experienceLevels: Record<string, number> = {};
    const remoteJobs = jobs.filter(job => job.isRemote).length;
    const totalJobs = jobs.length;

    jobs.forEach(job => {
      if (job.insights?.experienceLevel) {
        const level = job.insights.experienceLevel;
        experienceLevels[level] = (experienceLevels[level] || 0) + 1;
      }
    });

    const trends: MarketTrend[] = [];

    // Remote work trend
    const remotePercentage = Math.round((remoteJobs / totalJobs) * 100);
    if (remotePercentage > 30) {
      trends.push({
        trend: 'Remote Work Adoption',
        growth: remotePercentage > 60 ? 'rapidly increasing' : 'increasing',
        description: `${remotePercentage}% of job postings offer remote work options`,
        impact: 'Geographical barriers reduced, global talent competition increased'
      });
    }

    // Experience level trends
    const seniorJobs = (experienceLevels.senior || 0) + (experienceLevels.lead || 0) + (experienceLevels.principal || 0);
    const seniorPercentage = Math.round((seniorJobs / totalJobs) * 100);
    
    if (seniorPercentage > 40) {
      trends.push({
        trend: 'Senior Talent Demand',
        growth: 'increasing',
        description: `${seniorPercentage}% of positions target senior-level professionals`,
        impact: 'Strong demand for experienced developers, focus on leadership and architecture skills'
      });
    }

    // Default trend if no specific patterns found
    if (trends.length === 0) {
      trends.push({
        trend: 'Technology Evolution',
        growth: 'continuous',
        description: 'Constant evolution in technology stack requirements',
        impact: 'Need for continuous learning and adaptation to new technologies'
      });
    }

    return trends;
  }

  /**
   * Generates preparation advice based on analysis
   */
  private generatePreparationAdvice(skillGaps: SkillGap[], techStack: TechStackAnalysisResult[]): any {
    const immediate = [
      'Update resume to highlight modern tech stack experience',
      'Create portfolio showcasing best practices and clean code',
      'Optimize LinkedIn profile with relevant keywords'
    ];

    const shortTerm = [
      'Practice coding interviews and system design problems',
      'Build full-stack project with CI/CD pipeline'
    ];

    const longTerm = [
      'Contribute to major open source projects',
      'Build thought leadership through blogging or speaking'
    ];

    // Add skill-specific advice
    if (skillGaps.length > 0) {
      shortTerm.unshift(`Learn ${skillGaps[0].skill} to address major skill gap`);
    }

    if (techStack.length > 0) {
      immediate.push(`Showcase ${techStack[0].technology} projects prominently`);
    }

    return {
      immediate,
      shortTerm,
      longTerm
    };
  }

  /**
   * Helper methods
   */
  private calculateTrend(mentions: number, totalJobs: number): string {
    const percentage = (mentions / totalJobs) * 100;
    if (percentage > 70) return 'stable';
    if (percentage > 50) return 'rising';
    if (percentage > 30) return 'emerging';
    return 'niche';
  }

  private getTechnologyDescription(technology: string, frequency: number): string {
    const descriptions: Record<string, string> = {
      'React': `Frontend framework appearing in ${frequency}% of job postings`,
      'TypeScript': `Type-safe JavaScript variant used in ${frequency}% of positions`,
      'Node.js': `JavaScript runtime for backend development in ${frequency}% of jobs`,
      'Docker': `Containerization technology mentioned in ${frequency}% of postings`,
      'AWS': `Cloud platform referenced in ${frequency}% of job requirements`
    };
    
    return descriptions[technology] || `Technology mentioned in ${frequency}% of job postings`;
  }

  private generateLearningPath(skill: string): string {
    const paths: Record<string, string> = {
      'Kubernetes': 'Start with Docker mastery, then K8s fundamentals and certification',
      'GraphQL': 'Learn GraphQL basics, Apollo Client, and schema design',
      'TypeScript': 'Master JavaScript first, then TypeScript fundamentals and advanced types',
      'Docker': 'Learn containerization basics, Dockerfile creation, and orchestration',
      'AWS': 'Start with core services (EC2, S3, RDS), then pursue certification'
    };
    
    return paths[skill] || `Learn ${skill} fundamentals, build projects, and gain hands-on experience`;
  }

  private generateEnhancedLearningPath(skill: string, category: string, priority: string): string {
    const skillLower = skill.toLowerCase();
    
    // Specific technology paths
    const specificPaths: Record<string, string> = {
      'kubernetes': '1. Master Docker fundamentals 2. Complete K8s certification (CKA) 3. Build production-ready deployments',
      'docker': '1. Learn containerization concepts 2. Master Dockerfile best practices 3. Implement CI/CD with containers',
      'typescript': '1. Strengthen JavaScript foundations 2. Learn TS type system 3. Build large-scale applications',
      'graphql': '1. Understand REST vs GraphQL 2. Learn Apollo/Relay 3. Design efficient schemas',
      'aws': '1. Complete AWS Cloud Practitioner 2. Focus on core services (EC2, S3, Lambda) 3. Pursue Solutions Architect certification',
      'azure': '1. Learn cloud fundamentals 2. Complete AZ-900 certification 3. Specialize in relevant services',
      'react': '1. Master modern React patterns 2. Learn state management (Redux/Zustand) 3. Build performance-optimized apps',
      'vue': '1. Learn Vue 3 composition API 2. Master Nuxt.js framework 3. Build full-stack applications',
      'angular': '1. Learn TypeScript first 2. Master Angular CLI and services 3. Build enterprise applications',
      'node.js': '1. Master async programming 2. Learn Express/Fastify 3. Build scalable microservices',
      'python': '1. Learn syntax and core libraries 2. Master frameworks (Django/FastAPI) 3. Build data/ML applications',
      'golang': '1. Learn Go fundamentals 2. Master concurrency patterns 3. Build high-performance services',
      'rust': '1. Learn ownership and borrowing 2. Master async programming 3. Build systems-level applications'
    };

    if (specificPaths[skillLower]) {
      return specificPaths[skillLower];
    }

    // Category-based paths
    switch (category.toLowerCase()) {
      case 'frontend framework':
      case 'frontend':
        return `1. Learn ${skill} fundamentals 2. Build responsive applications 3. Master component patterns and state management`;
      case 'backend framework':
      case 'backend':
        return `1. Understand ${skill} architecture 2. Build RESTful APIs 3. Implement authentication and security`;
      case 'database':
        return `1. Learn ${skill} fundamentals 2. Master query optimization 3. Design scalable database schemas`;
      case 'cloud platform':
      case 'devops':
        return `1. Complete ${skill} certification 2. Practice infrastructure as code 3. Implement CI/CD pipelines`;
      case 'programming language':
        return `1. Master ${skill} syntax and idioms 2. Learn ecosystem and frameworks 3. Build production applications`;
      default:
        const timeframe = priority === 'Critical' ? '2-4 weeks' : priority === 'High' ? '1-2 months' : '2-3 months';
        return `1. Learn ${skill} fundamentals 2. Complete hands-on projects 3. Gain production experience (${timeframe})`;
    }
  }

  private generateGapReasoning(skill: string, frequency: number, category: string, userCategories: Set<string>): string {
    const isInUserCategory = userCategories.has(category.toLowerCase());
    
    if (frequency > 60) {
      return `Critical technology appearing in ${frequency}% of positions${isInUserCategory ? ' in your focus area' : ''}`;
    } else if (frequency > 40) {
      return `High-demand skill found in ${frequency}% of job postings${isInUserCategory ? ', expanding your existing expertise' : ''}`;
    } else if (frequency > 25) {
      return `Emerging technology in ${frequency}% of positions, growing market demand`;
    } else {
      return `Specialized skill in ${frequency}% of roles, valuable for career differentiation`;
    }
  }

  private capitalizeWords(str: string): string {
    return str.split(' ').map(word => 
      word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()
    ).join(' ');
  }

  private getMockSkillGaps(): SkillGap[] {
    return [
      {
        skill: "Kubernetes",
        priority: "High",
        frequency: 58,
        reasoning: "Container orchestration appears in 58% of senior positions",
        learningPath: "1. Master Docker fundamentals 2. Complete K8s certification (CKA) 3. Build production-ready deployments"
      },
      {
        skill: "TypeScript",
        priority: "High",
        frequency: 72,
        reasoning: "Type-safe development standard in 72% of modern applications",
        learningPath: "1. Strengthen JavaScript foundations 2. Learn TS type system 3. Build large-scale applications"
      },
      {
        skill: "AWS",
        priority: "Medium",
        frequency: 45,
        reasoning: "Cloud platform expertise required in 45% of positions",
        learningPath: "1. Complete AWS Cloud Practitioner 2. Focus on core services 3. Pursue Solutions Architect certification"
      }
    ];
  }

  /**
   * Fallback mock data methods
   */
  private getMockInsights(trackedJobs: number): any {
    return {
      techStackAnalysis: [
        {
          technology: "React",
          frequency: 85,
          category: "Frontend Framework",
          importance: "Critical",
          description: "Most requested frontend framework across job postings"
        }
      ],
      skillGaps: [
        {
          skill: "Kubernetes",
          priority: "High",
          frequency: 58,
          reasoning: "Container orchestration appears in 58% of senior positions",
          learningPath: "Start with Docker mastery, then K8s fundamentals and certification"
        }
      ],
      recommendations: [
        {
          type: "Upskill",
          title: "Master Cloud Architecture",
          priority: "High",
          description: "Cloud-native development is becoming the standard",
          actionItems: ["Complete AWS certification", "Build microservices project"],
          timeframe: "3-6 months"
        }
      ],
      marketTrends: [
        {
          trend: "AI-First Development",
          growth: "rapidly increasing",
          description: "Companies integrating AI into core products",
          impact: "High demand for AI integration skills"
        }
      ],
      preparationAdvice: {
        immediate: ["Update resume", "Create portfolio"],
        shortTerm: ["Learn TypeScript", "Build projects"],
        longTerm: ["Get certified", "Build thought leadership"]
      },
      metadata: {
        analyzedJobs: 0,
        trackedJobs,
        generatedAt: new Date().toISOString(),
        dataFreshness: 'mock'
      }
    };
  }

  private getMockTechTrends(userTrackedJobs: number): any {
    return {
      trendingTechnologies: [
        {
          technology: "React",
          mentions: 245,
          percentage: 85,
          category: "Frontend Framework",
          trend: "stable"
        }
      ],
      totalJobsAnalyzed: 0,
      userTrackedJobs,
      lastUpdated: new Date().toISOString()
    };
  }

  async cleanup(): Promise<void> {
    await this.db.close();
  }
}